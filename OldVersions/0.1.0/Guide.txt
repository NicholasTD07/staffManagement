碰到的问题:
    1.在第三版中,PutInSeq函数无效,因为不能对输入的变量进行操作.
    2.考虑改回第二版,使用直接的参数.





ProgramStructure:

	Functions:
		Generator([numbers],Shift="Day")
		
	Class:
		Method
			__init__
			AllStuff.Work(self)		(?)
			AllStuff.Details(self)
			AllStuff.AllTimes(self)

	Modules:
		pickle
		time



DataStructure:
	1.Class AllStuff:
		Class DayShift(AllStuff):
		Class NightShift(AllStuff):
	2.Fields:
		必须有的：号码，性别，这次上班次数，
		不确定需要的：历史上班次数,正在上班，


思考:
	如何实现整个等待的排序,以及上班的排序?
		等待的排序可以按照历史上班次数的升幂排列(最少的在最前面)
		上班的排序涉及到下面的规则.需要将其转换成逻辑规则.
Rules:

1.分时间段上班-----上班时间段
	a.白班 DayShift  12:00 - 19:00 
	b.高峰 AllStuff  19:00 - 24:00
	c.夜班 NightShift 24:00 - 12:00
2.星期天进行夜班的轮换------夜班轮换规则
3.高峰期班组排序规则---------高峰期合并规则
	a.如果所有白班技师都上过班了，则夜班技师放在白班技师的前面
	b.若白班技师只有一部分上班了，则将上过班的放在最后，夜班放中间
		白班（没上），夜班，白班（上了）
3.安排技师上班的排序规则（打牌子）--------上班规则
	a.客人无特殊要求，按照排好的顺序安排技师
	b.客人要求某个技师，则将该名技师的牌子放在已上钟的技师后面
	#  c(Q&A.2).若有上班技师将整个已上班技师分为两部分，则点钟放在此技师后面
	c.若选钟，则原地提出
	d.若之前有人被选钟，则后面点钟的技师只能放在他之后
	#e.若是选钟的特殊情况，但是需要后面的技师，则原地提取

	逻辑规则:
	1.三种工作类型:正常,点钟,选钟
	2.对应不同的工作类型的不同规则:
		选钟(Selected),原地提出
		正常,无论有没有选钟,都放在前面一部分的技师之后
		点钟(Named),分为两种情况,
			一,前面没有选钟,则直接放在当前序列最后
			二,前面有选钟,则只能放在选钟的人的后面.
	3.整个序列分为两种情况:
		1.无选钟:无论是正常还是点钟都直接排在序列的最后
		2.有选钟:此时,序列分为两组
			点钟排在选钟开始的第二序列的后面
			正常则继续排在第一序列的后面



Qs:
1. 每天最开始的排序是如何进行的?
2. 如果说已经有一次选钟的情况下,再次发生选钟怎么办?

Q&A:
1. 白班，夜班的分班是怎么分的？
	*a. 所有人分为三组，一组为夜班，其余为白班
	b. 夜班有专门的人，单独内部分组
2. 打牌子基本规则中2.(2)，技师将牌子分为两段是如何发生的？
		选钟：客人不知道该技师的号牌，原地提出
