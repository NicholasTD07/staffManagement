2012-04-09  20:03
    发现使用 list 作用工作序列的缺陷:
        当前面的员工离开时, 后面员工的序号会自动缩小.
    解决方案:
        利用 None, 替代离开的员工.

            21:00
    当占据 pos 的员工离开工作岗位, [n,s]Pos 并不会自动减小.
    会使空出的位置无法插入员工.
    解决方案 1 :
        当离开工作岗位的员工为 pos 所指的员工时,
            减小对应序号.
    失败:
        当员工乱序离开时, Pos 总是不等于 [n,s]Pos.
    解决方案 2 :
        将 nPos, 及 sPos 改为 list 类型.
        工作时添加, 等待时, 退出时自动移除.
        添加 员工 sType 属性, 方便查找.
            工作时自动更改, 等待时自动设置为WAIT.

2012-04-10  11:19
    问题:
        由于 sel 工作时 会向 nPos 中插入多余的值, 导致排序混乱.
    解决方案:
        取消 sel 工作时 插入 nPos 的功能.
        问题:
            原功能逻辑正确, 但是实现途径不完善.
            如果取消原功能, 会出现逻辑错误.

    新的解决方案:
        如果 sPos 插入位置 已有一个 员工.
        则在对应的 Pos 中去掉该号码.并且添加一个最大值加1的值.
                                相当于将 sPos 后面的值都加1.

            14:01
    问题:
        norWork 时, 插入工作的员工没有更新 sPos.

            23:07
    问题:
        sPos 的解决方案有漏洞.
        如果 2N, 4N, 5N, 6N, 2S -> 2S, 2N +1 .
        这样的情况, 会导致2N 变为3, 4->5.所以单独增加最大值无用.
        需要一个一个更新>= 2的 nPos.
        nPos 插入 同理.
    解决方案:
        list_new = list_org[0:index(pos)]+[ i+1 for i in list if i>pos]


2012-04-11
    问题:
        员工选钟工作时, 无论是否为插入正常工作序列都会更新selected.
        只有当员工不是插入正常工作序列时才更新selected.

            17:06
    问题:
        当员工等待时, pos 不能正常降低.

2012-04-12  11:08
    问题:
        现在的数据结构里面没有 wPos.
        在查看列表的对话框里面就没有可利用的资源来产生 等待序号.
    解决:
        添加 wPos, 修改上班, 等待的逻辑.
        问题:
            会有重复的 nPos, sPos.
            所以需要下面的方法.

        
    问题:
        现在的 nPos, sPos 中包含的都是下一个员工可用的位置, 
        考虑是否需要替换为 当前员工的位置, 而下一个员工的位置自加1.

2012-04-15  09:01
    问题:
        有了 wPos 之后, nPos, 和 sPos 就不能单独反映现在的队列了.
    解决方案:
        暂时不做等待表.并且回到 list-data-no-wait 分支.
        继续解决 放入 pos 而不是 pos + 1 的问题.

            09:27
    问题:
        正常工作员工会跳过 0位 上班,
        而选钟工作员工会由 0位 跳向 0位 上班.
        这样会造成 sPos 内的员工号比实际位置序号值小1.
    解决:
        向 nSeq 中添加一个 None 尝试解决.
